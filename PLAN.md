# План реализации ChatList

## Этап 1: Настройка проекта и инфраструктуры
### 1.1 Создание структуры проекта
- Создать виртуальное окружение Python
- Настроить `requirements.txt` с зависимостями:
  - PyQt6 для GUI
  - requests/httpx для HTTP запросов
  - python-dotenv для работы с переменными окружения
  - sqlite3 (входит в стандартную библиотеку)
- Создать базовую структуру папок:
  ```
  chatlist/
  ├── core/          # Бизнес-логика
  ├── db/            # Работа с базой данных
  ├── models/        # Модели нейросетей
  ├── ui/            # Графический интерфейс
  ├── utils/         # Утилиты
  ├── migrations/    # Миграции БД
  └── config/        # Конфигурация
  ```

### 1.2 Настройка системы конфигурации
- Создать `.env.example` с шаблоном переменных окружения
- Реализовать класс конфигурации для чтения настроек
- Настроить логирование

## Этап 2: Работа с базой данных
### 2.1 Создание схемы базы данных
- Написать SQL скрипты для создания таблиц
- Создать систему миграций для обновления схемы
- Реализовать класс DatabaseManager для управления подключением

### 2.2 Создание моделей данных
- Реализовать классы для работы с данными:
  - PromptManager для управления промптами
  - ModelManager для управления моделями
  - ResultManager для управления результатами
  - SettingsManager для управления настройками
- Добавить методы CRUD для каждой сущности

## Этап 3: API клиенты для нейросетей
### 3.1 Создание базового API клиента
- Реализовать абстрактный базовый класс для API клиентов
- Добавить обработку ошибок и таймаутов
- Реализовать асинхронные запросы для одновременной отправки

### 3.2 Реализация клиентов для конкретных моделей
- OpenAI GPT (ChatGPT)
- Anthropic Claude
- Google Gemini
- Другие популярные модели (опционально)
- Добавить поддержку кастомных моделей через конфигурацию

## Этап 4: Графический интерфейс
### 4.1 Создание главного окна
- Реализовать основное окно приложения с PyQt6
- Добавить меню и панель инструментов
- Настроить иконку и заголовок приложения

### 4.2 Интерфейс ввода промпта
- Создать область для ввода текста промпта
- Добавить возможность выбора из сохраненных промптов
- Реализовать управление тегами

### 4.3 Интерфейс выбора моделей
- Создать список доступных моделей с чекбоксами
- Добавить возможность включения/отключения моделей
- Показывать статус доступности API

### 4.4 Таблица результатов
- Реализовать таблицу для отображения ответов моделей
- Добавить столбцы: модель, ответ, время, токены
- Реализовать выделение и сохранение результатов

## Этап 5: Интеграция компонентов
### 5.1 Логика отправки запросов
- Реализовать класс RequestProcessor для координации запросов
- Добавить прогресс-бар для отображения статуса
- Реализовать отмену выполняющихся запросов

### 5.2 Обработка результатов
- Создать систему для сбора и отображения ответов
- Добавить возможность сравнения ответов
- Реализовать сохранение выбранных результатов

### 5.3 Управление настройками
- Создать интерфейс для настройки программы
- Добавить управление моделями (добавление/удаление/редактирование)
- Реализовать импорт/экспорт настроек

## Этап 6: Тестирование и доработка
### 6.1 Модульное тестирование
- Написать тесты для классов работы с БД
- Протестировать API клиентов
- Проверить корректность GUI

### 6.2 Интеграционное тестирование
- Тестирование полного цикла: ввод промпта → отправка → отображение результатов
- Проверка работы с разными моделями
- Тестирование сохранения и загрузки данных

### 6.3 Пользовательское тестирование
- Тестирование usability интерфейса
- Проверка производительности при множественных запросах
- Валидация обработки ошибок

## Этап 7: Финализация и развертывание
### 7.1 Оптимизация производительности
- Оптимизировать запросы к БД
- Улучшить асинхронную обработку запросов
- Добавить кеширование частых запросов

### 7.2 Документация
- Создать README.md с инструкцией по установке и использованию
- Добавить комментарии в код
- Создать документацию API (если планируется)

### 7.3 Сборка и упаковка
- Создать setup.py или pyproject.toml для установки
- Настроить создание исполняемого файла (PyInstaller)
- Подготовить релиз для разных платформ

## Приоритеты и зависимости

### Критические компоненты (этапы 1-3)
- Без них приложение не сможет работать
- Должны быть реализованы в первую очередь

### GUI компоненты (этап 4)
- Зависят от бизнес-логики
- Могут быть реализованы параллельно с API клиентами

### Интеграция и тестирование (этапы 5-6)
- Зависят от всех предыдущих компонентов
- Требуют полной работоспособности системы

### Финализация (этап 7)
- Оптимизации и полировка
- Могут быть отложены до базовой работоспособности

## Риски и mitigation

### Риски API
- Изменения в API провайдеров → Модульная архитектура клиентов для легкой замены
- Лимиты запросов → Добавление очередей и кеширования

### Риски производительности
- Медленная загрузка интерфейса → Ленивая загрузка компонентов
- Зависания при множественных запросах → Асинхронная обработка с отменой

### Риски совместимости
- Разные версии зависимостей → Фиксация версий в requirements.txt
- Проблемы с PyQt на разных ОС → Тестирование на целевых платформах

## Метрики успеха

- Приложение запускается без ошибок
- Успешная отправка запросов минимум в 2 модели
- Корректное отображение результатов в таблице
- Возможность сохранения и загрузки промптов
- Стабильная работа при 5+ одновременных запросах
- Время отклика UI < 100мс

---

# Этап 8: AI-ассистент для улучшения промтов

## 8.1 Архитектура и компоненты

### Основные компоненты:
- **PromptEnhancerClient**: Клиент для отправки промтов на улучшение выбранной LLM моделью
- **PromptEnhancerDialog**: UI диалоговое окно для работы с ассистентом
- **PromptEnhancerManager**: Менеджер для управления процессом улучшения и кешированием вариантов

### Интеграция с существующей архитектурой:
- Использование существующего OpenRouter клиента для отправки запросов
- Интеграция с таблицей prompts для сохранения истории улучшений
- Переиспользование стиля и темы основного приложения

## 8.2 Функциональность PromptEnhancerClient

### Основные методы:
1. `enhance_prompt(prompt: str, model_id: str, enhancement_type: str) -> EnhanceResult`
   - Параметры:
     - `prompt`: исходный текст промта для улучшения
     - `model_id`: ID выбранной модели для улучшения
     - `enhancement_type`: тип улучшения (general, code, analysis, creative)
   - Возвращаемое значение: объект с основным улучшением, вариантами и рекомендациями

2. Внутренние методы:
   - `_build_system_prompt(enhancement_type: str) -> str`
     - Создает system prompt для разных типов улучшений
     - Тип "general": улучшение четкости, структуры, деталей
     - Тип "code": адаптация для задач программирования
     - Тип "analysis": для задач анализа и исследования
     - Тип "creative": для творческих задач

   - `_parse_response(response: str) -> EnhanceResult`
     - Парсит ответ модели, извлекая:
       - Улучшенный промт
       - 2-3 альтернативных варианта
       - Объяснение изменений
       - Рекомендации для разных типов моделей

## 8.3 Структура данных EnhanceResult

```python
@dataclass
class EnhanceResult:
    original_prompt: str           # Исходный промт
    enhanced_prompt: str           # Основной улучшенный вариант
    alternatives: List[str]        # 2-3 альтернативных варианта
    explanation: str               # Объяснение произведенных изменений
    recommendations: Dict[str, str] # Рекомендации для разных типов моделей:
                                   # {"code": "...", "general": "...", "creative": "..."}
    model_id: str                  # ID модели, использованной для улучшения
    timestamp: datetime            # Время выполнения
```

## 8.4 UI: PromptEnhancerDialog

### Компоненты интерфейса:
1. **Левая панель (Input Section)**:
   - QLabel: "Исходный промт"
   - QTextEdit: Поле с исходным промтом (можно передать из основного окна)
   - QComboBox: Выбор типа улучшения (General, Code, Analysis, Creative)
   - QComboBox: Выбор модели для улучшения
   - QPushButton: "Улучшить промт" (активируется, если модель выбрана)
   - QProgressBar: Показать прогресс улучшения

2. **Правая панель (Results Section)**:
   - QTabWidget с вкладками:
     - **Вкладка "Улучшенный"**:
       - QTextEdit: Отображение основного улучшенного варианта (read-only)
       - QPushButton: "Копировать" (в буфер обмена)
       - QPushButton: "Подставить в поле ввода" (закрыть диалог и подставить текст)
       - QLabel: Показывает время выполнения и использованную модель
     
     - **Вкладка "Альтернативы"**:
       - QListWidget с вариантами улучшений
       - Для каждого варианта:
         - Текст варианта
         - Кнопка "Копировать"
         - Кнопка "Подставить"
     
     - **Вкладка "Рекомендации"**:
       - QTextEdit: Объяснение изменений
       - QGroupBox для каждого типа модели (Code, General, Creative):
         - QTextEdit: Рекомендации для адаптации под этот тип
   
   - QPushButton: "Закрыть диалог"

### Дизайн:
- Модальное окно поверх главного окна
- Размер: 1000x700 пиксела (по умолчанию)
- Сохранять размер и позицию окна в настройках
- Использовать сплиттер между left/right панелями (можно изменять ширину)

## 8.5 PromptEnhancerManager

### Основные методы:
1. `enhance_prompt(prompt: str, model_id: str, enhancement_type: str) -> EnhanceResult`
   - Оберточка вокруг PromptEnhancerClient
   - Управление ошибками и retry логика
   - Логирование запросов в БД

2. `get_enhancement_history(prompt_id: int = None) -> List[EnhanceResult]`
   - Получить историю улучшений для конкретного промта или всех промтов

3. `save_enhancement(enhancement: EnhanceResult, prompt_id: int = None) -> int`
   - Сохранить результат улучшения в новую таблицу `prompt_enhancements`

### Обработка ошибок:
- Таймауты при запросе к API (> 60 сек)
- Ошибки доступности выбранной модели
- Ошибки парсинга ответа модели
- Все ошибки показываются пользователю в отдельном QMessageBox

## 8.6 Интеграция с главным окном

### Добавить в главное окно (main_window.py):
1. Кнопка "Улучшить промт" в панели инструментов
   - Рядом с полем ввода промта
   - Иконка: звёздочка или палочка-выручалочка
   - Заголовок: "Improve prompt with AI"
   - При клике: открыть PromptEnhancerDialog с текущим промтом

2. Метод `_open_prompt_enhancer(self)`
   - Получить текущий промт из поля ввода
   - Открыть диалог PromptEnhancerDialog
   - При завершении: если пользователь выбрал вариант, подставить его в поле ввода

3. Добавить обработку сигналов:
   - `PromptEnhancerDialog.prompt_selected(str)` → вставить в поле ввода
   - `PromptEnhancerDialog.closed()` → обновить UI главного окна

## 8.7 База данных

### Новая таблица `prompt_enhancements`:
```sql
CREATE TABLE prompt_enhancements (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    original_prompt TEXT NOT NULL,
    enhanced_prompt TEXT NOT NULL,
    alternatives TEXT,  -- JSON с массивом альтернатив
    explanation TEXT,
    recommendations TEXT,  -- JSON с рекомендациями
    model_id INTEGER NOT NULL,
    enhancement_type TEXT,  -- general, code, analysis, creative
    prompt_id INTEGER,  -- FK на таблицу prompts (опционально)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (prompt_id) REFERENCES prompts(id),
    FOREIGN KEY (model_id) REFERENCES models(id)
);

CREATE INDEX idx_prompt_enhancements_prompt_id ON prompt_enhancements(prompt_id);
CREATE INDEX idx_prompt_enhancements_created_at ON prompt_enhancements(created_at);
```

## 8.8 System prompts для разных типов улучшений

### General (Общее улучшение):
> Ты - эксперт по написанию промтов для AI моделей. Улучши следующий промт:
> 
> Промт: {prompt}
> 
> Твоя задача:
> 1. Улучши четкость и структуру промта
> 2. Добавь специфические детали и контекст
> 3. Оптимизируй формулировки для лучшего понимания моделью
> 4. Предложи 2-3 альтернативных варианта переформулировки
> 5. Объясни, какие изменения были сделаны и почему
> 6. Дай рекомендации по адаптации этого промта для разных типов задач (код, анализ, творчество)
> 
> Форма ответа (JSON):
> {
>   "enhanced": "улучшенный промт",
>   "alternatives": ["вариант 1", "вариант 2", "вариант 3"],
>   "explanation": "объяснение изменений",
>   "recommendations": {
>     "code": "рекомендации для задач программирования",
>     "analysis": "рекомендации для анализа",
>     "creative": "рекомендации для творческих задач"
>   }
> }

### Code (Для программирования):
> Ты - эксперт по написанию промтов для AI моделей, специализирующийся на задачах программирования.
> Улучши следующий промт, специализируясь на задачах кодирования:
> [аналогично General, но с фокусом на код]

### Analysis (Для анализа):
> Ты - эксперт по написанию промтов для аналитических и исследовательских задач.
> [аналогично, с фокусом на анализ]

### Creative (Для творчества):
> Ты - эксперт по написанию промтов для творческих задач.
> [аналогично, с фокусом на творчество]

## 8.9 Обработка ошибок и edge cases

### Ошибки при улучшении:
1. Модель недоступна → показать сообщение "Выбранная модель сейчас недоступна"
2. Таймаут запроса → показать "Превышено время ожидания, попробуйте позже"
3. Ошибка парсинга JSON → показать "Ошибка обработки ответа модели, попробуйте другую"
4. Пустой промт → не позволить нажать кнопку "Улучшить" (disabled)

### Валидация:
- Минимальная длина промта: 10 символов
- Максимальная длина промта: 10000 символов
- Проверка выбора модели перед отправкой

## 8.10 Кеширование (опционально)

### Простое кеширование в памяти:
- Класс `PromptEnhancerCache` с LRU кешем (maxsize=100)
- Ключ кеша: `hash(prompt + model_id + enhancement_type)`
- Время жизни кеша: 24 часа (сохранять в БД)

### Методы:
- `get_cached(prompt_hash: str) -> Optional[EnhanceResult]`
- `set_cached(prompt_hash: str, result: EnhanceResult)`
- `clear_expired()`

## 8.11 Зависимости и требования

### Код зависит от:
- `chatlist.models.openrouter_client`: для отправки запросов
- `chatlist.db.database_manager`: для сохранения в БД
- `chatlist.db.model_manager`: для получения информации о моделях
- `chatlist.config.settings`: для конфигурации

### Новые импорты:
- `json` (стандартная библиотека) для парсинга JSON
- `dataclasses` (стандартная библиотека) для EnhanceResult
- `datetime` для timestamps
- `hashlib` для кеширования (опционально)

## 8.12 Тестирование

### Unit тесты:
- `test_prompt_enhancer_client.py`: тестирование парсинга ответов
- `test_prompt_enhancer_manager.py`: тестирование сохранения в БД
- `test_enhancement_result.py`: валидация структуры данных

### Интеграционные тесты:
- Отправка реального запроса на улучшение (с mock моделью)
- Сохранение и получение из БД
- Открытие/закрытие диалога в главном окне

### UI тесты:
- Проверка видимости компонентов
- Проверка включения/отключения кнопок
- Проверка передачи текста между окнами

## 8.13 Реализация: порядок шагов

1. **Шаг 1**: Создать класс `EnhanceResult` (dataclass)
2. **Шаг 2**: Реализовать `PromptEnhancerClient` с методами
3. **Шаг 3**: Реализовать `PromptEnhancerManager` с сохранением в БД
4. **Шаг 4**: Создать таблицу `prompt_enhancements` в миграциях
5. **Шаг 5**: Реализовать UI `PromptEnhancerDialog` (PyQt6)
6. **Шаг 6**: Интегрировать диалог в главное окно `main_window.py`
7. **Шаг 7**: Добавить обработку ошибок и валидацию
8. **Шаг 8**: Добавить простое кеширование (опционально)
9. **Шаг 9**: Написать тесты
10. **Шаг 10**: Документация и комментарии в коде

## 8.14 Метрики успеха для этого этапа

- ✅ Диалог открывается и закрывается корректно
- ✅ Запрос на улучшение отправляется в выбранную модель
- ✅ Ответ парсится и отображается в трех вкладках
- ✅ Кнопка "Подставить в поле ввода" правильно передает текст
- ✅ История улучшений сохраняется в БД
- ✅ Обработка всех типов ошибок с информативными сообщениями
- ✅ Время отклика диалога < 5 сек при нормальном интернете
- ✅ Все тесты проходят